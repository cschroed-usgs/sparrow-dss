<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.7" jmeter="2.12 r1636949">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
    </TestPlan>
    <hashTree>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="Dev Server Configuration Variables" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="ServiceHost" elementType="Argument">
            <stringProp name="Argument.name">ServiceHost</stringProp>
            <stringProp name="Argument.value">${__P(Host,cida-eros-sparrowdev.er.usgs.gov)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Takes a startup prop of name &apos;Host&apos; or uses &apos;cida-...&apos; if not provided.  Places in var &apos;Host&apos;.</stringProp>
          </elementProp>
          <elementProp name="ServicePort" elementType="Argument">
            <stringProp name="Argument.name">ServicePort</stringProp>
            <stringProp name="Argument.value">${__P(Port,8080)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ServiceContextPath" elementType="Argument">
            <stringProp name="Argument.name">ServiceContextPath</stringProp>
            <stringProp name="Argument.value">${__P(ContextPath,sparrow_mv)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapRequestsConcurrentUsers" elementType="Argument">
            <stringProp name="Argument.name">MapRequestsConcurrentUsers</stringProp>
            <stringProp name="Argument.value">${__P(MapRequestsConcurrentUsers,1)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Only one user is required to sequentially load models.  Larger than one is a stress test.</stringProp>
          </elementProp>
          <elementProp name="GeoserverHost" elementType="Argument">
            <stringProp name="Argument.name">GeoserverHost</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverHost,cida-eros-sparrowdev.er.usgs.gov)}</stringProp>
            <stringProp name="Argument.desc">Geoserver host name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeoserverPort" elementType="Argument">
            <stringProp name="Argument.name">GeoserverPort</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverPort,8081)}</stringProp>
            <stringProp name="Argument.desc">Geoserver port (8081 on dev, 8080 on others)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeoserverContextPath" elementType="Argument">
            <stringProp name="Argument.name">GeoserverContextPath</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverContextPath,sparrowgeoserver)}</stringProp>
            <stringProp name="Argument.desc">Geoserver context path</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MaxNumberOfModelsToRun" elementType="Argument">
            <stringProp name="Argument.name">MaxNumberOfModelsToRun</stringProp>
            <stringProp name="Argument.value">${__P(MaxNumberOfModelsToRun,1)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Filters how many models ids are queied fromGeoNetwork (sort order unknown)</stringProp>
          </elementProp>
          <elementProp name="MaxNumberOfTilesPerMap" elementType="Argument">
            <stringProp name="Argument.name">MaxNumberOfTilesPerMap</stringProp>
            <stringProp name="Argument.value">${__P(MaxNumberOfTilesPerMap,1)}</stringProp>
            <stringProp name="Argument.desc">Request all tiles for map (6x4=24) unless this is set to less than 24.  If less than 24, must be divisible by the number of ConcurrentUsers.  Disable by setting to 0 value.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapCatch" elementType="Argument">
            <stringProp name="Argument.name">MapCatch</stringProp>
            <stringProp name="Argument.value">${__P(MapCatch, true)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, catchments are mapped.  Otherwise, reahes are mapped.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapReach" elementType="Argument">
            <stringProp name="Argument.name">MapReach</stringProp>
            <stringProp name="Argument.value">${__P(MapReach, true)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, reaches are mapped.  Otherwise, reahes are mapped.</stringProp>
          </elementProp>
          <elementProp name="MapStaticLayers" elementType="Argument">
            <stringProp name="Argument.name">MapStaticLayers</stringProp>
            <stringProp name="Argument.value">${__P(MapStaticLayers, false)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, the reference only layers are requested, such as reach overlay, calibration sites and catchment overlay.  False by default.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="RandomizeContexts" elementType="Argument">
            <stringProp name="Argument.name">RandomizeContexts</stringProp>
            <stringProp name="Argument.value">${__P(RandomizeContexts, true)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, a random adjustment is added to each context to force new context Ids and map layers</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkHost" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkHost</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkHost,cida-eros-sparrowdev.er.usgs.gov)}</stringProp>
            <stringProp name="Argument.desc">Geonetwork host name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkPort" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkPort</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkPort,8080)}</stringProp>
            <stringProp name="Argument.desc">Geonetwork port (8080 on all unless using public urls)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkContextPath" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkContextPath</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkContextPath,sparrow/sparrow_geonetwork)}</stringProp>
            <stringProp name="Argument.desc">Geoserver context path</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EnableAppLevelDebugMessages" elementType="Argument">
            <stringProp name="Argument.name">EnableAppLevelDebugMessages</stringProp>
            <stringProp name="Argument.value">${__P(EnableAppLevelDebugMessages, true)}</stringProp>
            <stringProp name="Argument.desc">Set to true to turn on app level debug msg&apos;s, which are on the level of one per tile requested.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
        <stringProp name="TestPlan.comments">How many users and how many of each map each user requests.</stringProp>
      </Arguments>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="QA Server Configuration Variables" enabled="false">
        <collectionProp name="Arguments.arguments">
          <elementProp name="ServiceHost" elementType="Argument">
            <stringProp name="Argument.name">ServiceHost</stringProp>
            <stringProp name="Argument.value">${__P(ServiceHost,cida-eros-sparrowsvcqa2)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Takes a startup prop of name &apos;Host&apos; or uses &apos;cida-...&apos; if not provided.  Places in var &apos;Host&apos;.</stringProp>
          </elementProp>
          <elementProp name="ServicePort" elementType="Argument">
            <stringProp name="Argument.name">ServicePort</stringProp>
            <stringProp name="Argument.value">${__P(ServicePort,8080)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="ServiceContextPath" elementType="Argument">
            <stringProp name="Argument.name">ServiceContextPath</stringProp>
            <stringProp name="Argument.value">${__P(ServiceContextPath,sparrow_mv)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapRequestsConcurrentUsers" elementType="Argument">
            <stringProp name="Argument.name">MapRequestsConcurrentUsers</stringProp>
            <stringProp name="Argument.value">${__P(MapRequestsConcurrentUsers,24)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Only one user is required to sequentially load models.  Larger than one is a stress test.</stringProp>
          </elementProp>
          <elementProp name="GeoserverHost" elementType="Argument">
            <stringProp name="Argument.name">GeoserverHost</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverHost,cida-eros-sparrowsvcqa1)}</stringProp>
            <stringProp name="Argument.desc">Geoserver host name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeoserverPort" elementType="Argument">
            <stringProp name="Argument.name">GeoserverPort</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverPort,8080)}</stringProp>
            <stringProp name="Argument.desc">Geoserver port (8081 on dev, 8080 on others)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeoserverContextPath" elementType="Argument">
            <stringProp name="Argument.name">GeoserverContextPath</stringProp>
            <stringProp name="Argument.value">${__P(GeoserverContextPath,sparrowgeoserver)}</stringProp>
            <stringProp name="Argument.desc">Geoserver context path</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MaxNumberOfModelsToRun" elementType="Argument">
            <stringProp name="Argument.name">MaxNumberOfModelsToRun</stringProp>
            <stringProp name="Argument.value">${__P(MaxNumberOfModelsToRun,99)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">Filters how many models ids are queied fromGeoNetwork (sort order unknown)</stringProp>
          </elementProp>
          <elementProp name="MaxNumberOfTilesPerMap" elementType="Argument">
            <stringProp name="Argument.name">MaxNumberOfTilesPerMap</stringProp>
            <stringProp name="Argument.value">${__P(MaxNumberOfTilesPerMap,0)}</stringProp>
            <stringProp name="Argument.desc">Request all tiles for map (6x4=24) unless this is set to less than 24.  If less than 24, must be divisible by the number of ConcurrentUsers.  Disable by setting to 0 value.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapCatch" elementType="Argument">
            <stringProp name="Argument.name">MapCatch</stringProp>
            <stringProp name="Argument.value">${__P(MapCatch, true)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, catchments are mapped.  Otherwise, reahes are mapped.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="MapReach" elementType="Argument">
            <stringProp name="Argument.name">MapReach</stringProp>
            <stringProp name="Argument.value">${__P(MapReach, true)}</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, reaches are mapped.  Otherwise, reahes are mapped.</stringProp>
          </elementProp>
          <elementProp name="MapStaticLayers" elementType="Argument">
            <stringProp name="Argument.name">MapStaticLayers</stringProp>
            <stringProp name="Argument.value">${__P(MapStaticLayers, false)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, the reference only layers are requested, such as reach overlay, calibration sites and catchment overlay.  False by default.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="RandomizeContexts" elementType="Argument">
            <stringProp name="Argument.name">RandomizeContexts</stringProp>
            <stringProp name="Argument.value">${__P(RandomizeContexts, true)}</stringProp>
            <stringProp name="Argument.desc">If &apos;true&apos;, a random adjustment is added to each context to force new context Ids and map layers</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkHost" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkHost</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkHost,cida-eros-sparrowguiqa1)}</stringProp>
            <stringProp name="Argument.desc">Geonetwork host name</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkPort" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkPort</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkPort,8080)}</stringProp>
            <stringProp name="Argument.desc">Geonetwork port (8080 on all unless using public urls)</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="GeonetworkContextPath" elementType="Argument">
            <stringProp name="Argument.name">GeonetworkContextPath</stringProp>
            <stringProp name="Argument.value">${__P(GeonetworkContextPath,sparrow/sparrow_geonetwork)}</stringProp>
            <stringProp name="Argument.desc">Geoserver context path</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="EnableAppLevelDebugMessages" elementType="Argument">
            <stringProp name="Argument.name">EnableAppLevelDebugMessages</stringProp>
            <stringProp name="Argument.value">${__P(EnableAppLevelDebugMessages, false)}</stringProp>
            <stringProp name="Argument.desc">Set to true to turn on app level debug msg&apos;s, which are on the level of one per tile requested.</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
        <stringProp name="TestPlan.comments">How many users and how many of each map each user requests.</stringProp>
      </Arguments>
      <hashTree/>
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
          <collectionProp name="Arguments.arguments"/>
        </elementProp>
        <stringProp name="HTTPSampler.domain">${ServiceHost}</stringProp>
        <stringProp name="HTTPSampler.port">${ServicePort}</stringProp>
        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
        <stringProp name="HTTPSampler.response_timeout"></stringProp>
        <stringProp name="HTTPSampler.protocol">http</stringProp>
        <stringProp name="HTTPSampler.contentEncoding"></stringProp>
        <stringProp name="HTTPSampler.path"></stringProp>
        <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
      </ConfigTestElement>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>true</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="StatGraphVisualizer" testclass="ResultCollector" testname="Aggregate Graph" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>true</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="View Results in Table" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>true</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Prep Requests" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">stoptest</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1418315545000</longProp>
        <longProp name="ThreadGroup.end_time">1418315545000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <CSVDataSet guiclass="TestBeanGUI" testclass="CSVDataSet" testname="CSV Data Set Config" enabled="false">
          <stringProp name="delimiter">,</stringProp>
          <stringProp name="fileEncoding"></stringProp>
          <stringProp name="filename">../resources/id_model_numbers.csv</stringProp>
          <boolProp name="quotedData">true</boolProp>
          <boolProp name="recycle">false</boolProp>
          <stringProp name="shareMode">shareMode.group</stringProp>
          <boolProp name="stopThread">true</boolProp>
          <stringProp name="variableNames">modelId,lat,long,themeName</stringProp>
          <stringProp name="TestPlan.comments">Loads a set of models from a text file.</stringProp>
        </CSVDataSet>
        <hashTree/>
        <OnceOnlyController guiclass="OnceOnlyControllerGui" testclass="OnceOnlyController" testname="Only Once - Clear Properties" enabled="true"/>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Model List" enabled="true">
            <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
              <collectionProp name="Arguments.arguments">
                <elementProp name="" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">&lt;csw:GetRecords xmlns:csw=&quot;http://www.opengis.net/cat/csw/2.0.2&quot; xmlns:ogc=&quot;http://www.opengis.net/ogc&quot; xmlns:ows=&quot;http://www.opengis.net/ows&quot; xmlns:gml=&quot;http://www.opengis.net/gml&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; service=&quot;CSW&quot; version=&quot;2.0.2&quot; maxRecords=&quot;${MaxNumberOfModelsToRun}&quot; startPosition=&quot;1&quot; outputFormat=&quot;application/xml&quot; outputSchema=&quot;http://www.isotc211.org/2005/gmd&quot; resultType=&quot;results&quot;&gt;&lt;csw:Query typeNames=&quot;csw:Record&quot;&gt;&lt;csw:ElementSetName&gt;full&lt;/csw:ElementSetName&gt;&lt;ogc:SortBy&gt;&lt;ogc:SortProperty&gt;&lt;ogc:PropertyName&gt;title&lt;/ogc:PropertyName&gt;&lt;ogc:SortOrder&gt;ASC&lt;/ogc:SortOrder&gt;&lt;/ogc:SortProperty&gt;&lt;/ogc:SortBy&gt;&lt;/csw:Query&gt;&lt;/csw:GetRecords&gt;&#xd;
</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain">${GeonetworkHost}</stringProp>
            <stringProp name="HTTPSampler.port">${GeonetworkPort}</stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding"></stringProp>
            <stringProp name="HTTPSampler.path">/${GeonetworkContextPath}/query</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP Header Manager" enabled="true">
              <collectionProp name="HeaderManager.headers">
                <elementProp name="" elementType="Header">
                  <stringProp name="Header.name">content-type</stringProp>
                  <stringProp name="Header.value">application/xml</stringProp>
                </elementProp>
              </collectionProp>
            </HeaderManager>
            <hashTree/>
            <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="Regular Expression Extractor" enabled="true">
              <stringProp name="RegexExtractor.useHeaders">false</stringProp>
              <stringProp name="RegexExtractor.refname">geoNetworkModelIds</stringProp>
              <stringProp name="RegexExtractor.regex">&lt;gco:CharacterString&gt;(\d+)&lt;/gco:CharacterString&gt;\s*&lt;/gmd:keyword&gt;\s*&lt;gmd:type&gt;\s*&lt;gmd:MD_KeywordTypeCode codeList=&quot;\S*&quot;\s*codeListValue=&quot;sparrow_dss_model_id&quot;</stringProp>
              <stringProp name="RegexExtractor.template">$1$</stringProp>
              <stringProp name="RegexExtractor.default"></stringProp>
              <stringProp name="RegexExtractor.match_number">-1</stringProp>
            </RegexExtractor>
            <hashTree/>
          </hashTree>
          <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init all static properties" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">//JMeter properties seem to persist from run to run, so explicitly clear them out.
log.info(&quot;***** Initializing all static properties&quot;);

log.info(&quot;     Configured Test Properties:&quot;);
log.info(&quot;     ServiceHost: &quot; + vars.get(&quot;ServiceHost&quot;));
log.info(&quot;     ServicePort: &quot; + vars.get(&quot;ServicePort&quot;));
log.info(&quot;     ServiceContextPath: &quot; + vars.get(&quot;ServiceContextPath&quot;));
log.info(&quot;     MapRequestsConcurrentUsers: &quot; + vars.get(&quot;MapRequestsConcurrentUsers&quot;));
log.info(&quot;     GeoserverHost: &quot; + vars.get(&quot;GeoserverHost&quot;));
log.info(&quot;     GeoserverPort: &quot; + vars.get(&quot;GeoserverPort&quot;));
log.info(&quot;     GeoserverContextPath: &quot; + vars.get(&quot;GeoserverContextPath&quot;));
log.info(&quot;     MapCatch: &quot; + vars.get(&quot;MapCatch&quot;));
log.info(&quot;     MapReach: &quot; + vars.get(&quot;MapReach&quot;));
log.info(&quot;     MaxNumberOfTilesPerMap: &quot; + vars.get(&quot;MaxNumberOfTilesPerMap&quot;));
log.info(&quot;     RandomizeContexts: &quot; + vars.get(&quot;RandomizeContexts&quot;));
log.info(&quot;     GeonetworkHost: &quot; + vars.get(&quot;GeonetworkHost&quot;));
log.info(&quot;     GeonetworkPort: &quot; + vars.get(&quot;GeonetworkPort&quot;));
log.info(&quot;     GeonetworkContextPath: &quot; + vars.get(&quot;GeonetworkContextPath&quot;));
log.info(&quot;     EnableAppLevelDebugMessages: &quot; + vars.get(&quot;EnableAppLevelDebugMessages&quot;));
	
//
// Some initial default values


//Basic numbers
var maxNumberOfTilesPerMap = Number(vars.get(&quot;MaxNumberOfTilesPerMap&quot;));
var tilesWide = 6;	//should only be even numbers
var tilesTall = 4;	//should only be even numbers
var tilesTotal = tilesWide * tilesTall;
var mappedTilesTotal = tilesTotal;

//restrict total number of tiles to map only if less than then the number of tiles in the map and not turned off by setting to zero.
if (maxNumberOfTilesPerMap &lt; tilesTotal &amp;&amp; maxNumberOfTilesPerMap &gt; 0) mappedTilesTotal = maxNumberOfTilesPerMap;

var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var tilesPerUser = Math.floor(tilesTotal / users);	//How many tiles one user/thread WOULD need to request to request the entire map (may not request all)
var mappedTilesPerUser = Math.floor(mappedTilesTotal / users);	//How many tiles one user/thread will actually request to request (may not be entire map)
var randomCoef = Math.random() * 2.0;	//somewhere between 0 and 2


if (tilesPerUser != Math.ceil(tilesTotal / users)) {
	log.error(&quot;MapRequestsConcurrentUsers is specified as &quot; + users + &quot;, however, there are &quot; + tilesTotal + 
	&quot; in the map, which is not divisible by &quot; + users + &quot;.  Please  specify MapRequestsConcurrentUsers to go evenly into the number of tiles.&quot;);
	ctx.getEngine().stopEngineNow();
}


if (maxNumberOfTilesPerMap &gt; 0 &amp;&amp; mappedTilesPerUser != Math.ceil(maxNumberOfTilesPerMap / users)) {
	log.error(&quot;MapRequestsConcurrentUsers is specified as &quot; + users + &quot;, however, MaxNumberOfTilesPerMap is spec&apos;ed as &quot; + maxNumberOfTilesPerMap + 
	&quot; which is not divisible by &quot; + users + &quot;.  Please  specify MaxNumberOfTilesPerMap as a multiple of the number of users.&quot;);
	ctx.getEngine().stopEngineNow();
}


//Put props
// Any props listed here should also be listed in the Only Once - Clear Properties script
props.put(&quot;EnableAppLevelDebugMessages&quot;, vars.get(&quot;EnableAppLevelDebugMessages&quot;)); //Enable app level debug 
props.put(&quot;allModelMeta&quot;, {});	//Object Data structure containing all model data 
props.put(&quot;modelIds&quot;, []);		//Array of all model ids
props.put(&quot;modelCount&quot;, 0);		//will update after all the model metadata is loaded
props.put(&quot;modelIdIndex&quot;, 0);			//pointer into modelIds
props.remove(&quot;modelId&quot;);				//the actual current model id from modelIds - no current value, so just clear it

props.put(&quot;tilesWide&quot;, tilesWide);
props.put(&quot;tilesTall&quot;, tilesTall);
props.put(&quot;tilesTotal&quot;, tilesTotal);
props.put(&quot;mappedTilesTotal&quot;, mappedTilesTotal);
props.put(&quot;tilesPerUser&quot;, tilesPerUser);
props.put(&quot;mappedTilesPerUser&quot;, mappedTilesPerUser);
props.put(&quot;randomCoef&quot;, randomCoef);	//Use for randomized coef&apos;s in context adjustments so we force new context id and map layers for each run

props.put(&quot;contextIdIndex&quot;, 0);			//If we register multiple contexts per model, this points to the current one

if (mappedTilesTotal == tilesTotal) {
	log.info(&quot;----- Initializing all static properties.  There will be &quot; + users + &quot; concurrent map tiles requests (threads) to request &quot; + 
		tilesTotal + &quot; total tiles per context.  Thus, there are &quot; + tilesPerUser + &quot; tiles per thread.&quot;);
} else {
	log.info(&quot;----- Initializing all static properties.  There will be &quot; + users + &quot; concurrent map tiles requests (threads) to request &quot; + 
		mappedTilesTotal + &quot; tiles per context.  Thus, there are &quot; + mappedTilesPerUser + &quot; tiles per thread.  NOTE: This is not the total number of tiles in a map - it was restricted by the MaxNumberOfTilesPerMap param.&quot;);
}
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFSampler>
          <hashTree/>
        </hashTree>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Model" enabled="true">
          <stringProp name="ForeachController.inputVal">geoNetworkModelIds</stringProp>
          <stringProp name="ForeachController.returnVal">modelId</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
        </ForeachController>
        <hashTree>
          <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Get Model Metadata" enabled="true">
            <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
              <collectionProp name="Arguments.arguments">
                <elementProp name="xmlreq" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">true</boolProp>
                  <stringProp name="Argument.name">xmlreq</stringProp>
                  <stringProp name="Argument.value">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;&lt;sparrow-meta-request   xmlns=&quot;http://www.usgs.gov/sparrow/meta_request/v0_1&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;  &lt;model id=&quot;${modelId}&quot; &gt;  &lt;/model&gt;&lt;/sparrow-meta-request&gt;</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                </elementProp>
                <elementProp name="mimetype" elementType="HTTPArgument">
                  <boolProp name="HTTPArgument.always_encode">false</boolProp>
                  <stringProp name="Argument.value">json</stringProp>
                  <stringProp name="Argument.metadata">=</stringProp>
                  <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  <stringProp name="Argument.name">mimetype</stringProp>
                </elementProp>
              </collectionProp>
            </elementProp>
            <stringProp name="HTTPSampler.domain"></stringProp>
            <stringProp name="HTTPSampler.port"></stringProp>
            <stringProp name="HTTPSampler.connect_timeout"></stringProp>
            <stringProp name="HTTPSampler.response_timeout"></stringProp>
            <stringProp name="HTTPSampler.protocol"></stringProp>
            <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
            <stringProp name="HTTPSampler.path">/${ServiceContextPath}/sp_model/formpost</stringProp>
            <stringProp name="HTTPSampler.method">POST</stringProp>
            <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
            <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
            <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
            <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
            <stringProp name="HTTPSampler.implementation">Java</stringProp>
            <boolProp name="HTTPSampler.monitor">false</boolProp>
            <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          </HTTPSamplerProxy>
          <hashTree>
            <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Verify Staus" enabled="true">
              <collectionProp name="Asserion.test_strings">
                <stringProp name="855760879">&quot;bounds&quot;:</stringProp>
              </collectionProp>
              <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
              <boolProp name="Assertion.assume_success">false</boolProp>
              <intProp name="Assertion.test_type">2</intProp>
            </ResponseAssertion>
            <hashTree/>
            <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="Build Model MetaData" enabled="true">
              <stringProp name="filename"></stringProp>
              <stringProp name="parameters"></stringProp>
              <stringProp name="script">var modelId = vars.get(&quot;modelId&quot;).toString();	//the model ID from the CSV file

log.info(&quot;***** Build Model MetaData for model &quot; + modelId + &quot; begin on thread number &quot; + ctx.getThreadNum() + &quot; (should always be thread 0)&quot;);


//Parse data from the request - this is metadata for one model
var respBody = prev.getResponseDataAsString();
var oneMetaData = JSON.parse(respBody);


//The properties objects to add this data to (will be null for the first model)
var allMetaData = props.get(&quot;allModelMeta&quot;);
var modelIds = props.get(&quot;modelIds&quot;);


//Quick access to some constants from props
var tilesWide = Number(props.get(&quot;tilesWide&quot;));
var tilesTall = Number(props.get(&quot;tilesTall&quot;));
var tilesTotal = Number(props.get(&quot;tilesTotal&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));


//List of zoom sizes.  &apos;zoom&apos; numbers are refs to the actual index the app uses (ref only).  Here we just use the struct as a zero based array.
//These should all be genericized as the first one is....
var zoomSizes = [
	{zoom:7, size:0.703125, mapWidth:(tilesWide * 0.703125), mapHeight:(tilesTall * 0.703125)},
	{zoom:6, size:1.40625, mapWidth:(tilesWide * 1.40625), mapHeight:(tilesTall * 1.40625)},
	{zoom:5, size:2.8125, mapWidth:(tilesWide * 2.8125), mapHeight:(tilesTall * 2.8125)},
	{zoom:4, size:5.625, mapWidth:(tilesWide * 5.625), mapHeight:(tilesTall * 5.625)},
	{zoom:3, size:11.25, mapWidth:(tilesWide * 11.25), mapHeight:(tilesTall * 11.25)},
	{zoom:2, size:22.5, mapWidth:(tilesWide * 22.5), mapHeight:(tilesTall * 22.5)},
];


var bounds = oneMetaData.models.model[0].bounds;
var orgNorth = Number(bounds[&quot;@north&quot;]);
var orgWest = Number(bounds[&quot;@west&quot;]);
var orgSouth = Number(bounds[&quot;@south&quot;]);
var orgEast = Number(bounds[&quot;@east&quot;]);
var orgWidth = orgEast - orgWest;
var orgHeight = orgNorth - orgSouth;
var orgLongCenter = orgWest + (orgWidth / 2);
var orgLatCenter = orgSouth + (orgHeight / 2);

log.info(&quot;Found these original map bounds for model &quot; + modelId + &quot;:   &quot; + orgWest + &quot;,&quot; + orgSouth + &quot;,&quot; + orgEast + &quot;,&quot; + orgNorth);


var zoomIndex = -1;	//Index into zoomSizes

for (zi = 0; zi &lt; zoomSizes.length; zi++) {

	//Fit width &amp; height is based one one tile non-visible to the user
	var fitWidth = zoomSizes[zi].size * (tilesWide - 1);	
	var fitHeight = zoomSizes[zi].size * (tilesTall - 1);
	
	if (fitWidth &gt; orgWidth &amp;&amp; fitHeight &gt; orgHeight) {
		//this zoom is the one to use
		zoomIndex = zi;
		break;
	}
}

if (zoomIndex == -1) {
	log.error(&quot;Unable to find a suitable zoom level model model &quot; + modelId);
	ctx.getEngine().stopEngineNow();
}

//Find lat long center using the selected zoom
//This is the number of tiles from lat/long 0,0.
var tilesWestToCenter = Math.round(orgLongCenter / zoomSizes[zoomIndex].size);
var tilesNorthToCenter = Math.round(orgLatCenter / zoomSizes[zoomIndex].size);

//Center in lat/long
var alignedLongCenter = tilesWestToCenter * zoomSizes[zoomIndex].size;
var alignedLatCenter = tilesNorthToCenter * zoomSizes[zoomIndex].size;

//Map edges - initial zoomed out view
var alignedNorth = alignedLatCenter + (zoomSizes[zoomIndex].size * tilesTall / 2);
var alignedWest = alignedLongCenter - (zoomSizes[zoomIndex].size * tilesWide / 2);
var alignedSouth = alignedLatCenter - (zoomSizes[zoomIndex].size * tilesTall / 2);
var alignedEast = alignedLongCenter + (zoomSizes[zoomIndex].size * tilesWide / 2);

//Map edges - one level zoomed in
var zoom1North = alignedLatCenter + (zoomSizes[zoomIndex].size * tilesTall / 4);
var zoom1West = alignedLongCenter - (zoomSizes[zoomIndex].size * tilesWide / 4);
var zoom1South = alignedLatCenter - (zoomSizes[zoomIndex].size * tilesTall / 4);
var zoom1East = alignedLongCenter + (zoomSizes[zoomIndex].size * tilesWide / 4);

log.info(&quot;Created these adjusted map bounds for model &quot; + modelId + &quot;:   &quot; + alignedWest + &quot;,&quot; + alignedSouth + &quot;,&quot; + alignedEast + &quot;,&quot; + alignedNorth);
log.debug(&quot;alignedLongCenter:&quot; + alignedLongCenter + &quot; alignedLatCenter:&quot; + alignedLatCenter);

//Make Tile Bounds.  Row columns are 0,0 at bottom left corner
//var initViewTiles = [];
var initViewTiles = makeTiles(alignedSouth, alignedWest, tilesTall, tilesWide, zoomSizes[zoomIndex].size);
var zoom1ViewTiles = makeTiles(zoom1South, zoom1West, tilesTall, tilesWide, zoomSizes[zoomIndex - 1].size);


allMetaData[&quot;&quot; + modelId] = {
	originalBbox: {north: orgNorth, west: orgWest, south: orgSouth, east: orgEast},
	alignedBbox:  {north: alignedNorth, west: alignedWest, south: alignedSouth, east: alignedEast},
	initViewTiles: initViewTiles,
	zoom1ViewTiles: zoom1ViewTiles,
	contextIds: [],
	flowLayerNames: [],
	catchLayerNames: [],
	localLayerNames: []
};

modelIds.push(modelId);


//The list of model ids, a pointer and the current one.
//Only the list of modelIds is updated here, the other are just init&apos;ed here as placeholders
props.put(&quot;allModelMeta&quot;, allMetaData);	//Data structure containing all model data 
props.put(&quot;modelIds&quot;, modelIds);	//list of all model ids
props.put(&quot;modelId&quot;, modelIds[0]);	//the actual current model id from modelIds (just keep setting to the first model, which is how we want it b/f entering the mapping section)

log.info(&quot;----- Build Model MetaData for model &quot; + modelId + &quot; complete.&quot;);


function makeTiles(south, west, tilesTall, tilesWide, tileLatLongSize) {
	//Make Tile Bounds.  Row columns are 0,0 at bottom left corner
	var tiles = [];
	for (row = 0; row &lt; tilesTall; row++) {
		for (col = 0; col &lt; tilesWide; col++) {
			var tile = {
				west: (west + tileLatLongSize * col),
				south: (south + tileLatLongSize * row),
				east: (west + tileLatLongSize * (col + 1)),
				north: (south + tileLatLongSize * (row + 1)),
				rowcol: &quot;r&quot; + row + &quot;c&quot; + col
			};
	
			log.debug(&quot;Created tile :   &quot; + tile.west + &quot;,&quot; + tile.south + &quot;,&quot; + tile.east + &quot;,&quot; + tile.north);
			
			tiles.push(tile);
		}
	}

	//Reorder the tiles so that they spiral out from the center.
	//This allows us to just request the first few tiles in the list
	//and make sure we actually get tiles with geom, rather than empty edge tiles.
	//I tried a few spiral calc implementations, but... its complicated.  Below is the
	//solution for the 6 x 4 grid - we just display a warning if that is not the tile arrangement.
	if (tilesTall == 4 &amp;&amp; tilesWide == 6) {
		var spiral = [];

		spiral.push(tiles[8]);
		spiral.push(tiles[9]);
		spiral.push(tiles[15]);
		spiral.push(tiles[14]);
		spiral.push(tiles[13]);
		spiral.push(tiles[7]);
		spiral.push(tiles[1]);
		spiral.push(tiles[2]);
		spiral.push(tiles[3]);
		spiral.push(tiles[4]);
		spiral.push(tiles[10]);
		spiral.push(tiles[16]);
		spiral.push(tiles[22]);
		spiral.push(tiles[21]);
		spiral.push(tiles[20]);
		spiral.push(tiles[19]);
		spiral.push(tiles[18]);
		spiral.push(tiles[12]);
		spiral.push(tiles[6]);
		spiral.push(tiles[0]);
		spiral.push(tiles[5]);
		spiral.push(tiles[11]);
		spiral.push(tiles[17]);
		spiral.push(tiles[23]);

		return spiral;

		
	} else {
		log.error(&quot;WARNING:  THIS SECTION OF CODE ASSUMES THAT THE MAP GRID IS 6X4.  SINCE IT IS NOT, THE SPIRAL TILE ARRANGEMENT WILL BE SKIPPED MEANING THAT THE FIRST REQUESTED TILES WILL BE EDGES RATHER THAN THE MIDDLE OF THE MAP.&quot;);
		return tiles;
	}

	
}
</stringProp>
              <stringProp name="scriptLanguage">javascript</stringProp>
            </BSFPostProcessor>
            <hashTree/>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Randomized Contexts" enabled="true">
            <stringProp name="IfController.condition">${RandomizeContexts}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Register Context ID (randomized)" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="xmlreq" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">true</boolProp>
                    <stringProp name="Argument.name">xmlreq</stringProp>
                    <stringProp name="Argument.value">&lt;PredictionContext xmlns=&quot;http://www.usgs.gov/sparrow/prediction-schema/v0_2&quot; 	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; model-id=&quot;${modelId}&quot;&gt; 	&lt;adjustmentGroups conflicts=&quot;accumulate&quot;&gt; 		&lt;default-group enabled=&quot;true&quot;&gt; 			&lt;desc/&gt; 			&lt;notes/&gt; 			&lt;adjustment src=&quot;1&quot; coef=&quot;${randomCoef}&quot;/&gt; 		&lt;/default-group&gt; 	&lt;/adjustmentGroups&gt; 	&lt;analysis&gt; 		&lt;dataSeries source=&quot;&quot;&gt;total&lt;/dataSeries&gt; 		&lt;groupBy aggFunction=&quot;avg&quot;/&gt; 	&lt;/analysis&gt; 	&lt;terminalReaches/&gt; 	&lt;areaOfInterest/&gt; 	&lt;nominalComparison type=&quot;none&quot;/&gt; &lt;/PredictionContext&gt;</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
              <stringProp name="HTTPSampler.path">/${ServiceContextPath}/sp_predictcontext/formpost</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.implementation">Java</stringProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var randomCoef = props.get(&quot;randomCoef&quot;);
vars.put(&quot;randomCoef&quot;, randomCoef);</stringProp>
              </BSFPreProcessor>
              <hashTree/>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Verify Staus" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="467472849">&lt;status&gt;OK&lt;/status</stringProp>
                </collectionProp>
                <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">2</intProp>
              </ResponseAssertion>
              <hashTree/>
              <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="Context ID XPath Extractor" enabled="true">
                <stringProp name="XPathExtractor.default"></stringProp>
                <stringProp name="XPathExtractor.refname">contextIdBasic</stringProp>
                <stringProp name="XPathExtractor.xpathQuery">//*[local-name() = &apos;PredictionContext-response&apos; ]/@context-id</stringProp>
                <boolProp name="XPathExtractor.validate">false</boolProp>
                <boolProp name="XPathExtractor.tolerant">false</boolProp>
                <boolProp name="XPathExtractor.namespace">false</boolProp>
              </XPathExtractor>
              <hashTree/>
              <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var modelId = vars.get(&quot;modelId&quot;);

log.info(&quot;***** Register context for model &quot; + modelId);

var allMetaData = props.get(&quot;allModelMeta&quot;);
var contextId = vars.get(&quot;contextIdBasic&quot;);


var modelMeta = allMetaData[modelId];
var contextIds = modelMeta[&quot;contextIds&quot;];

contextIds.push(contextId);


props.put(&quot;allModelMeta&quot;, allMetaData);
	</stringProp>
              </BSFPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Non-Randomized Contexts" enabled="true">
            <stringProp name="IfController.condition">${RandomizeContexts} != &apos;true&apos;</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Register Context ID (non-randomized)" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="xmlreq" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">true</boolProp>
                    <stringProp name="Argument.name">xmlreq</stringProp>
                    <stringProp name="Argument.value">&lt;PredictionContext xmlns=&quot;http://www.usgs.gov/sparrow/prediction-schema/v0_2&quot; 	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; model-id=&quot;${modelId}&quot;&gt; 	&lt;adjustmentGroups conflicts=&quot;accumulate&quot;&gt; 		&lt;individualGroup enabled=&quot;true&quot;/&gt; 	&lt;/adjustmentGroups&gt; 	&lt;analysis&gt; 		&lt;dataSeries source=&quot;&quot;&gt;total&lt;/dataSeries&gt; 		&lt;groupBy aggFunction=&quot;avg&quot;/&gt; 	&lt;/analysis&gt; 	&lt;terminalReaches/&gt; 	&lt;areaOfInterest/&gt; 	&lt;nominalComparison type=&quot;none&quot;/&gt; &lt;/PredictionContext&gt;</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
              <stringProp name="HTTPSampler.path">/${ServiceContextPath}/sp_predictcontext/formpost</stringProp>
              <stringProp name="HTTPSampler.method">POST</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.implementation">Java</stringProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var randomCoef = props.get(&quot;randomCoef&quot;);
vars.put(&quot;randomCoef&quot;, randomCoef);</stringProp>
              </BSFPreProcessor>
              <hashTree/>
              <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Verify Staus" enabled="true">
                <collectionProp name="Asserion.test_strings">
                  <stringProp name="467472849">&lt;status&gt;OK&lt;/status</stringProp>
                </collectionProp>
                <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
                <boolProp name="Assertion.assume_success">false</boolProp>
                <intProp name="Assertion.test_type">2</intProp>
              </ResponseAssertion>
              <hashTree/>
              <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="Context ID XPath Extractor" enabled="true">
                <stringProp name="XPathExtractor.default"></stringProp>
                <stringProp name="XPathExtractor.refname">contextIdBasic</stringProp>
                <stringProp name="XPathExtractor.xpathQuery">//*[local-name() = &apos;PredictionContext-response&apos; ]/@context-id</stringProp>
                <boolProp name="XPathExtractor.validate">false</boolProp>
                <boolProp name="XPathExtractor.tolerant">false</boolProp>
                <boolProp name="XPathExtractor.namespace">false</boolProp>
              </XPathExtractor>
              <hashTree/>
              <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var modelId = vars.get(&quot;modelId&quot;);

log.info(&quot;***** Register context for model &quot; + modelId);

var allMetaData = props.get(&quot;allModelMeta&quot;);
var contextId = vars.get(&quot;contextIdBasic&quot;);


var modelMeta = allMetaData[modelId];
var contextIds = modelMeta[&quot;contextIds&quot;];

contextIds.push(contextId);


props.put(&quot;allModelMeta&quot;, allMetaData);
	</stringProp>
              </BSFPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
        </hashTree>
        <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Finish init the model metadata" enabled="true"/>
        <hashTree>
          <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Final Model Metadata setup" enabled="true">
            <stringProp name="scriptLanguage">javascript</stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="filename"></stringProp>
            <stringProp name="script">var modelIds = props.get(&quot;modelIds&quot;);
props.put(&quot;modelCount&quot;, modelIds.length);

//Reset a pointer to the current context.
//Can be used later to load multiple contexts for a given model
props.put(&quot;contextIdIndex&quot;, 0);

log.info(&quot;----- Final Model Metadata configuration complete for &quot; + modelIds.length + &quot; models.&quot;);</stringProp>
          </BSFSampler>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Map Requests" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${MapRequestsConcurrentUsers}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">0</stringProp>
        <longProp name="ThreadGroup.start_time">1288709161000</longProp>
        <longProp name="ThreadGroup.end_time">1288709161000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Over Each Model" enabled="true">
          <boolProp name="LoopController.continue_forever">true</boolProp>
          <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;modelCount&quot;)))}</stringProp>
        </LoopController>
        <hashTree>
          <IfController guiclass="IfControllerPanel" testclass="IfController" testname="Register Layer by 1st Thread Only" enabled="true">
            <stringProp name="IfController.condition">${__javaScript(ctx.getThreadNum() == 0)}</stringProp>
            <boolProp name="IfController.evaluateAll">false</boolProp>
            <boolProp name="IfController.useExpression">true</boolProp>
          </IfController>
          <hashTree>
            <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Register Map Layers" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                <collectionProp name="Arguments.arguments">
                  <elementProp name="context-id" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">true</boolProp>
                    <stringProp name="Argument.name">context-id</stringProp>
                    <stringProp name="Argument.value">${contextId}</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                  </elementProp>
                  <elementProp name="projected-srs" elementType="HTTPArgument">
                    <boolProp name="HTTPArgument.always_encode">true</boolProp>
                    <stringProp name="Argument.value">EPSG:4326</stringProp>
                    <stringProp name="Argument.metadata">=</stringProp>
                    <boolProp name="HTTPArgument.use_equals">true</boolProp>
                    <stringProp name="Argument.name">projected-srs</stringProp>
                  </elementProp>
                </collectionProp>
              </elementProp>
              <stringProp name="HTTPSampler.domain"></stringProp>
              <stringProp name="HTTPSampler.port"></stringProp>
              <stringProp name="HTTPSampler.connect_timeout"></stringProp>
              <stringProp name="HTTPSampler.response_timeout"></stringProp>
              <stringProp name="HTTPSampler.protocol"></stringProp>
              <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
              <stringProp name="HTTPSampler.path">/${ServiceContextPath}/RegisterMapLayerService</stringProp>
              <stringProp name="HTTPSampler.method">GET</stringProp>
              <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
              <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
              <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
              <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
              <stringProp name="HTTPSampler.implementation">Java</stringProp>
              <boolProp name="HTTPSampler.monitor">false</boolProp>
              <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
            </HTTPSamplerProxy>
            <hashTree>
              <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="Do initial Mapping init - must be first for all map related requests" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var modelIdIndex = Number(props.get(&quot;modelIdIndex&quot;));			//pointer into modelIds
var modelIds = props.get(&quot;modelIds&quot;);
var modelId = modelIds[modelIdIndex];
var allMetaData = props.get(&quot;allModelMeta&quot;);
var modelMeta = allMetaData[modelId];
var contextIdIndex = Number(props.get(&quot;contextIdIndex&quot;));
var contextId = modelMeta.contextIds[contextIdIndex];


log.info(&quot;***** Register map layer for &quot; + modelId + &quot; context &quot; + contextId + &quot; BEGIN by thread number &quot; + ctx.getThreadNum() + &quot; (should be 0).&quot;);


//Update for the next model - don&apos;t use past this point
var nextModelIdIndex = modelIdIndex + 1;	


props.put(&quot;modelId&quot;, modelId);
props.put(&quot;modelIdIndex&quot;, nextModelIdIndex);	//No longer valid at this point - should only be used here.
props.put(&quot;currentModel&quot;, modelMeta);
props.put(&quot;contextId&quot;, contextId);
vars.put(&quot;contextId&quot;, contextId);	//put in two places - here is for access by the current thread to for access during the http request to register the layer</stringProp>
              </BSFPreProcessor>
              <hashTree/>
              <XPathAssertion guiclass="XPathAssertionGui" testclass="XPathAssertion" testname="Verify Status" enabled="true">
                <boolProp name="XPath.negate">false</boolProp>
                <stringProp name="XPath.xpath">//Status[text()=&apos;OK&apos;]</stringProp>
                <boolProp name="XPath.validate">false</boolProp>
                <boolProp name="XPath.whitespace">false</boolProp>
                <boolProp name="XPath.tolerant">false</boolProp>
                <boolProp name="XPath.namespace">false</boolProp>
              </XPathAssertion>
              <hashTree/>
              <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="Flowline Layer Name Extractor" enabled="true">
                <stringProp name="XPathExtractor.default"></stringProp>
                <stringProp name="XPathExtractor.refname">flowLayerName</stringProp>
                <stringProp name="XPathExtractor.xpathQuery">//FlowLayerName</stringProp>
                <boolProp name="XPathExtractor.validate">false</boolProp>
                <boolProp name="XPathExtractor.tolerant">false</boolProp>
                <boolProp name="XPathExtractor.namespace">false</boolProp>
              </XPathExtractor>
              <hashTree/>
              <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="Catchment Layer Name Extractor" enabled="true">
                <stringProp name="XPathExtractor.default"></stringProp>
                <stringProp name="XPathExtractor.refname">catchLayerName</stringProp>
                <stringProp name="XPathExtractor.xpathQuery">//CatchLayerName</stringProp>
                <boolProp name="XPathExtractor.validate">false</boolProp>
                <boolProp name="XPathExtractor.tolerant">false</boolProp>
                <boolProp name="XPathExtractor.namespace">false</boolProp>
              </XPathExtractor>
              <hashTree/>
              <XPathExtractor guiclass="XPathExtractorGui" testclass="XPathExtractor" testname="Catchment Local Layer Name Extract" enabled="true">
                <stringProp name="TestPlan.comments">flow and catch layers have the same local name.</stringProp>
                <stringProp name="XPathExtractor.default"></stringProp>
                <stringProp name="XPathExtractor.refname">localLayerName</stringProp>
                <stringProp name="XPathExtractor.xpathQuery">substring-after(//CatchLayerName, &apos;:&apos;)</stringProp>
                <boolProp name="XPathExtractor.validate">false</boolProp>
                <boolProp name="XPathExtractor.tolerant">false</boolProp>
                <boolProp name="XPathExtractor.namespace">false</boolProp>
              </XPathExtractor>
              <hashTree/>
              <BSFPostProcessor guiclass="TestBeanGUI" testclass="BSFPostProcessor" testname="BSF PostProcessor" enabled="true">
                <stringProp name="scriptLanguage">javascript</stringProp>
                <stringProp name="parameters"></stringProp>
                <stringProp name="filename"></stringProp>
                <stringProp name="script">var allMetaData = props.get(&quot;allModelMeta&quot;);
var modelMeta = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextId = props.get(&quot;contextId&quot;);

var flowLayerNames = modelMeta[&quot;flowLayerNames&quot;];
var catchLayerNames = modelMeta[&quot;catchLayerNames&quot;];
var localLayerNames = modelMeta[&quot;localLayerNames&quot;];


flowLayerNames.push(vars.get(&quot;flowLayerName&quot;));
catchLayerNames.push(vars.get(&quot;catchLayerName&quot;));
localLayerNames.push(vars.get(&quot;localLayerName&quot;));


props.put(&quot;allModelMeta&quot;, allMetaData);
props.put(&quot;currentModel&quot;, modelMeta);


log.info(&quot;----- Register map layer for &quot; + modelId + &quot; context &quot; + contextId + &quot; DONE&quot;);</stringProp>
              </BSFPostProcessor>
              <hashTree/>
            </hashTree>
          </hashTree>
          <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Map Requests" enabled="true"/>
          <hashTree>
            <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP Request Defaults" enabled="true">
              <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
                <collectionProp name="Arguments.arguments"/>
              </elementProp>
              <stringProp name="HTTPSampler.domain">${ServiceHost}</stringProp>
              <stringProp name="HTTPSampler.port">${ServicePort}</stringProp>
              <stringProp name="HTTPSampler.connect_timeout">5000</stringProp>
              <stringProp name="HTTPSampler.response_timeout">20000</stringProp>
              <stringProp name="HTTPSampler.protocol">http</stringProp>
              <stringProp name="HTTPSampler.contentEncoding"></stringProp>
              <stringProp name="HTTPSampler.path"></stringProp>
              <stringProp name="TestPlan.comments">Add some timeouts so that the test will eventually give up on failed map tiles</stringProp>
              <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
            </ConfigTestElement>
            <hashTree/>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Zoomed out initial model view" enabled="true"/>
            <hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Mapping Catch" enabled="true">
                <stringProp name="IfController.condition">${MapCatch}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
              </IfController>
              <hashTree>
                <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                  <stringProp name="groupSize">${MapRequestsConcurrentUsers}</stringProp>
                  <longProp name="timeoutInMs">0</longProp>
                </SyncTimer>
                <hashTree/>
                <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Reset thread to loop tiles" enabled="true">
                  <stringProp name="scriptLanguage">javascript</stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">vars.put(&quot;threadLoopIndex&quot;, -1);</stringProp>
                </BSFSampler>
                <hashTree/>
                <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Zoomed out initial model view catch Transaction" enabled="true">
                  <boolProp name="TransactionController.includeTimers">false</boolProp>
                  <boolProp name="TransactionController.parent">false</boolProp>
                </TransactionController>
                <hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop all map tiles for map (catch zoomed out view)" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;mappedTilesPerUser&quot;)))}</stringProp>
                  </LoopController>
                  <hashTree>
                    <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init thread for a single tile request" enabled="true">
                      <stringProp name="scriptLanguage">javascript</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">var isDebug = props.get(&quot;EnableAppLevelDebugMessages&quot;);
var model = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextIndex = Number(props.get(&quot;contextIndex&quot;));
var contextId = props.get(&quot;contextId&quot;);
var totalTiles = Number(props.get(&quot;tilesTotal&quot;));
//var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var threadLoopIndex = vars.get(&quot;threadLoopIndex&quot;);	//How many times has this thread looped through the map loop?

//Starts at -1, so always increment before use
threadLoopIndex = Number(threadLoopIndex) + 1;


var tileIndex = ctx.getThreadNum() + (users * threadLoopIndex);	//Determine the tile to render based on the thread number &amp; how many times this thread has looped
var tile = model[&quot;initViewTiles&quot;][tileIndex];

if (isDebug == &quot;true&quot;) {
	log.info(&quot;Will map a zoomed out catch tile for &quot; + modelId + 
	&quot; on thread &quot; + ctx.getThreadNum() + &quot; threadLoopIndex &quot; + threadLoopIndex + &quot; for tile index &quot; + tileIndex);
}


vars.put(&quot;modelId&quot;, modelId);
vars.put(&quot;contextId&quot;, contextId);
vars.put(&quot;north&quot;, Number(tile[&quot;north&quot;]));
vars.put(&quot;west&quot;, Number(tile[&quot;west&quot;]));
vars.put(&quot;south&quot;, Number(tile[&quot;south&quot;]));
vars.put(&quot;east&quot;, Number(tile[&quot;east&quot;]));
vars.put(&quot;flowLayerName&quot;, model[&quot;flowLayerNames&quot;][contextIndex]);
vars.put(&quot;catchLayerName&quot;, model[&quot;catchLayerNames&quot;][contextIndex]);
vars.put(&quot;localLayerName&quot;, model[&quot;localLayerNames&quot;][contextIndex]);


//debug &amp; index info
vars.put(&quot;thdnum&quot;, ctx.getThreadNum());
vars.put(&quot;threadLoopIndex&quot;, threadLoopIndex);
vars.put(&quot;tileIndex&quot;, tileIndex);
vars.put(&quot;contextIndex&quot;, contextIndex);
vars.put(&quot;rowcol&quot;, tile[&quot;rowcol&quot;]);</stringProp>
                    </BSFSampler>
                    <hashTree/>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Zoomed Out Catch Tile" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments">
                          <elementProp name="thdNum" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${thdnum}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">thdNum</stringProp>
                          </elementProp>
                          <elementProp name="modelId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${modelId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">modelId</stringProp>
                          </elementProp>
                          <elementProp name="contextId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextId</stringProp>
                          </elementProp>
                          <elementProp name="contextIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextIdx</stringProp>
                          </elementProp>
                          <elementProp name="tileIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${tileIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">tileIdx</stringProp>
                          </elementProp>
                          <elementProp name="rowcol" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${rowcol}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">rowcol</stringProp>
                          </elementProp>
                          <elementProp name="threadLoopIndex" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${threadLoopIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">threadLoopIndex</stringProp>
                          </elementProp>
                          <elementProp name="request" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">GetMap</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">request</stringProp>
                          </elementProp>
                          <elementProp name="srs" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">EPSG:4326</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">srs</stringProp>
                          </elementProp>
                          <elementProp name="version" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">1.1.1</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">version</stringProp>
                          </elementProp>
                          <elementProp name="layers" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${catchLayerName}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">layers</stringProp>
                          </elementProp>
                          <elementProp name="BBOX" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${west},${south},${east},${north}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">BBOX</stringProp>
                          </elementProp>
                          <elementProp name="width" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">width</stringProp>
                          </elementProp>
                          <elementProp name="height" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">height</stringProp>
                          </elementProp>
                          <elementProp name="transparent" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">true</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">transparent</stringProp>
                          </elementProp>
                          <elementProp name="format" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">image/png8</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format</stringProp>
                          </elementProp>
                          <elementProp name="styles" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value"></stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">styles</stringProp>
                          </elementProp>
                          <elementProp name="format_options" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">antialiasing:none;quantizer:octree;</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format_options</stringProp>
                          </elementProp>
                          <elementProp name="sld" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">http://${GeoserverHost}:${GeoserverPort}/${GeoserverContextPath}/rest/sld/workspace/sparrow-catchment/layer/${localLayerName}/catch.sld?binLowList=0,25000,58000,141000,676000&amp;binHighList=25000,58000,141000,676000,500000000&amp;binColorList=FFFFD4,FEE391,FEC44F,FE9929,EC7014&amp;bounded=false</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">sld</stringProp>
                          </elementProp>
                        </collectionProp>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${GeoserverHost}</stringProp>
                      <stringProp name="HTTPSampler.port">${GeoserverPort}</stringProp>
                      <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="HTTPSampler.protocol"></stringProp>
                      <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                      <stringProp name="HTTPSampler.path">/${GeoserverContextPath}/wms</stringProp>
                      <stringProp name="HTTPSampler.method">GET</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.implementation">Java</stringProp>
                      <boolProp name="HTTPSampler.monitor">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    </HTTPSamplerProxy>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Mapping Reach" enabled="true">
                <stringProp name="IfController.condition">${MapReach}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
              </IfController>
              <hashTree>
                <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                  <stringProp name="groupSize">${MapRequestsConcurrentUsers}</stringProp>
                  <longProp name="timeoutInMs">0</longProp>
                </SyncTimer>
                <hashTree/>
                <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Reset thread to loop tiles" enabled="true">
                  <stringProp name="scriptLanguage">javascript</stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">vars.put(&quot;threadLoopIndex&quot;, -1);</stringProp>
                </BSFSampler>
                <hashTree/>
                <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Zoomed out initial model view reach Transaction" enabled="true">
                  <boolProp name="TransactionController.includeTimers">false</boolProp>
                  <boolProp name="TransactionController.parent">false</boolProp>
                </TransactionController>
                <hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop all map tiles for map (reach zoomed out view)" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;mappedTilesPerUser&quot;)))}</stringProp>
                  </LoopController>
                  <hashTree>
                    <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init thread for a single tile request" enabled="true">
                      <stringProp name="scriptLanguage">javascript</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">var isDebug = props.get(&quot;EnableAppLevelDebugMessages&quot;);
var model = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextIndex = Number(props.get(&quot;contextIndex&quot;));
var contextId = props.get(&quot;contextId&quot;);
var totalTiles = Number(props.get(&quot;tilesTotal&quot;));
//var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var threadLoopIndex = vars.get(&quot;threadLoopIndex&quot;);	//How many times has this thread looped through the map loop?

//Starts at -1, so always increment before use
threadLoopIndex = Number(threadLoopIndex) + 1;


var tileIndex = ctx.getThreadNum() + (users * threadLoopIndex);	//Determine the tile to render based on the thread number &amp; how many times this thread has looped
var tile = model[&quot;initViewTiles&quot;][tileIndex];

if (isDebug == &quot;true&quot;) {
	log.info(&quot;Will map a zoomed out reach tile for &quot; + modelId + 
	&quot; on thread &quot; + ctx.getThreadNum() + &quot; threadLoopIndex &quot; + threadLoopIndex + &quot; for tile index &quot; + tileIndex);
}


vars.put(&quot;modelId&quot;, modelId);
vars.put(&quot;contextId&quot;, contextId);
vars.put(&quot;north&quot;, Number(tile[&quot;north&quot;]));
vars.put(&quot;west&quot;, Number(tile[&quot;west&quot;]));
vars.put(&quot;south&quot;, Number(tile[&quot;south&quot;]));
vars.put(&quot;east&quot;, Number(tile[&quot;east&quot;]));
vars.put(&quot;flowLayerName&quot;, model[&quot;flowLayerNames&quot;][contextIndex]);
vars.put(&quot;catchLayerName&quot;, model[&quot;catchLayerNames&quot;][contextIndex]);
vars.put(&quot;localLayerName&quot;, model[&quot;localLayerNames&quot;][contextIndex]);


//debug &amp; index info
vars.put(&quot;thdnum&quot;, ctx.getThreadNum());
vars.put(&quot;threadLoopIndex&quot;, threadLoopIndex);
vars.put(&quot;tileIndex&quot;, tileIndex);
vars.put(&quot;contextIndex&quot;, contextIndex);
vars.put(&quot;rowcol&quot;, tile[&quot;rowcol&quot;]);</stringProp>
                    </BSFSampler>
                    <hashTree/>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Zoomed Out Reach Tile" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments">
                          <elementProp name="thdNum" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${thdnum}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">thdNum</stringProp>
                          </elementProp>
                          <elementProp name="modelId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${modelId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">modelId</stringProp>
                          </elementProp>
                          <elementProp name="contextId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextId</stringProp>
                          </elementProp>
                          <elementProp name="contextIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextIdx</stringProp>
                          </elementProp>
                          <elementProp name="tileIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${tileIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">tileIdx</stringProp>
                          </elementProp>
                          <elementProp name="rowcol" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${rowcol}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">rowcol</stringProp>
                            <stringProp name="Argument.desc">false</stringProp>
                          </elementProp>
                          <elementProp name="threadLoopIndex" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${threadLoopIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">threadLoopIndex</stringProp>
                          </elementProp>
                          <elementProp name="request" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">GetMap</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">request</stringProp>
                          </elementProp>
                          <elementProp name="srs" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">EPSG:4326</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">srs</stringProp>
                          </elementProp>
                          <elementProp name="version" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">1.1.1</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">version</stringProp>
                          </elementProp>
                          <elementProp name="layers" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${flowLayerName}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">layers</stringProp>
                          </elementProp>
                          <elementProp name="BBOX" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${west},${south},${east},${north}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">BBOX</stringProp>
                          </elementProp>
                          <elementProp name="width" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">width</stringProp>
                          </elementProp>
                          <elementProp name="height" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">height</stringProp>
                          </elementProp>
                          <elementProp name="transparent" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">true</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">transparent</stringProp>
                          </elementProp>
                          <elementProp name="format" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">image/png8</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format</stringProp>
                          </elementProp>
                          <elementProp name="styles" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value"></stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">styles</stringProp>
                          </elementProp>
                          <elementProp name="format_options" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">antialiasing:none;quantizer:octree;</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format_options</stringProp>
                          </elementProp>
                          <elementProp name="sld" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">http://${GeoserverHost}:${GeoserverPort}/${GeoserverContextPath}/rest/sld/workspace/sparrow-flowline/layer/${localLayerName}/catch.sld?binLowList=0,25000,58000,141000,676000&amp;binHighList=25000,58000,141000,676000,500000000&amp;binColorList=FFFFD4,FEE391,FEC44F,FE9929,EC7014&amp;bounded=false</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">sld</stringProp>
                          </elementProp>
                        </collectionProp>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${GeoserverHost}</stringProp>
                      <stringProp name="HTTPSampler.port">${GeoserverPort}</stringProp>
                      <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="HTTPSampler.protocol"></stringProp>
                      <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                      <stringProp name="HTTPSampler.path">/${GeoserverContextPath}/wms</stringProp>
                      <stringProp name="HTTPSampler.method">GET</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.implementation">Java</stringProp>
                      <boolProp name="HTTPSampler.monitor">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    </HTTPSamplerProxy>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Mapping Static Layers" enabled="true">
                <stringProp name="IfController.condition">${MapStaticLayers}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
              </IfController>
              <hashTree>
                <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                  <stringProp name="groupSize">${MapRequestsConcurrentUsers}</stringProp>
                  <longProp name="timeoutInMs">0</longProp>
                </SyncTimer>
                <hashTree/>
                <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Reset thread to loop tiles" enabled="true">
                  <stringProp name="scriptLanguage">javascript</stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">vars.put(&quot;threadLoopIndex&quot;, -1);</stringProp>
                </BSFSampler>
                <hashTree/>
                <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Zoomed out initial model view static-layers Transaction" enabled="true">
                  <boolProp name="TransactionController.includeTimers">false</boolProp>
                  <boolProp name="TransactionController.parent">false</boolProp>
                </TransactionController>
                <hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop all map tiles for map (static zoomed out view)" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;mappedTilesPerUser&quot;)))}</stringProp>
                  </LoopController>
                  <hashTree>
                    <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init thread for a single tile request" enabled="true">
                      <stringProp name="scriptLanguage">javascript</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">var isDebug = props.get(&quot;EnableAppLevelDebugMessages&quot;);
var model = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextIndex = Number(props.get(&quot;contextIndex&quot;));
var contextId = props.get(&quot;contextId&quot;);
var totalTiles = Number(props.get(&quot;tilesTotal&quot;));
//var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var threadLoopIndex = vars.get(&quot;threadLoopIndex&quot;);	//How many times has this thread looped through the map loop?

//Starts at -1, so always increment before use
threadLoopIndex = Number(threadLoopIndex) + 1;


var tileIndex = ctx.getThreadNum() + (users * threadLoopIndex);	//Determine the tile to render based on the thread number &amp; how many times this thread has looped
var tile = model[&quot;initViewTiles&quot;][tileIndex];

if (isDebug == &quot;true&quot;) {
	log.info(&quot;Will map a zoomed out reach tile for &quot; + modelId + 
	&quot; on thread &quot; + ctx.getThreadNum() + &quot; threadLoopIndex &quot; + threadLoopIndex + &quot; for tile index &quot; + tileIndex);
}


vars.put(&quot;modelId&quot;, modelId);
vars.put(&quot;contextId&quot;, contextId);
vars.put(&quot;north&quot;, Number(tile[&quot;north&quot;]));
vars.put(&quot;west&quot;, Number(tile[&quot;west&quot;]));
vars.put(&quot;south&quot;, Number(tile[&quot;south&quot;]));
vars.put(&quot;east&quot;, Number(tile[&quot;east&quot;]));
vars.put(&quot;flowLayerName&quot;, model[&quot;flowLayerNames&quot;][contextIndex]);
vars.put(&quot;catchLayerName&quot;, model[&quot;catchLayerNames&quot;][contextIndex]);
vars.put(&quot;localLayerName&quot;, model[&quot;localLayerNames&quot;][contextIndex]);


//debug &amp; index info
vars.put(&quot;thdnum&quot;, ctx.getThreadNum());
vars.put(&quot;threadLoopIndex&quot;, threadLoopIndex);
vars.put(&quot;tileIndex&quot;, tileIndex);
vars.put(&quot;contextIndex&quot;, contextIndex);
vars.put(&quot;rowcol&quot;, tile[&quot;rowcol&quot;]);</stringProp>
                    </BSFSampler>
                    <hashTree/>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Zoomed Out Calibration Tile (NOT COMPLETE)" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments">
                          <elementProp name="thdNum" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${thdnum}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">thdNum</stringProp>
                          </elementProp>
                          <elementProp name="modelId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${modelId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">modelId</stringProp>
                          </elementProp>
                          <elementProp name="contextId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextId</stringProp>
                          </elementProp>
                          <elementProp name="contextIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextIdx</stringProp>
                          </elementProp>
                          <elementProp name="tileIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${tileIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">tileIdx</stringProp>
                          </elementProp>
                          <elementProp name="rowcol" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${rowcol}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">rowcol</stringProp>
                            <stringProp name="Argument.desc">false</stringProp>
                          </elementProp>
                          <elementProp name="threadLoopIndex" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${threadLoopIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">threadLoopIndex</stringProp>
                          </elementProp>
                          <elementProp name="request" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">GetMap</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">request</stringProp>
                          </elementProp>
                          <elementProp name="srs" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">EPSG:4326</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">srs</stringProp>
                          </elementProp>
                          <elementProp name="version" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">1.1.1</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">version</stringProp>
                          </elementProp>
                          <elementProp name="layers" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${flowLayerName}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">layers</stringProp>
                          </elementProp>
                          <elementProp name="BBOX" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${west},${south},${east},${north}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">BBOX</stringProp>
                          </elementProp>
                          <elementProp name="width" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">width</stringProp>
                          </elementProp>
                          <elementProp name="height" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">height</stringProp>
                          </elementProp>
                          <elementProp name="transparent" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">true</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">transparent</stringProp>
                          </elementProp>
                          <elementProp name="format" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">image/png8</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format</stringProp>
                          </elementProp>
                          <elementProp name="styles" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value"></stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">styles</stringProp>
                          </elementProp>
                          <elementProp name="format_options" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">antialiasing:none;quantizer:octree;</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format_options</stringProp>
                          </elementProp>
                          <elementProp name="sld" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">http://${GeoserverHost}:${GeoserverPort}/${GeoserverContextPath}/rest/sld/workspace/sparrow-flowline/layer/${localLayerName}/catch.sld?binLowList=0,25000,58000,141000,676000&amp;binHighList=25000,58000,141000,676000,500000000&amp;binColorList=FFFFD4,FEE391,FEC44F,FE9929,EC7014&amp;bounded=false</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">sld</stringProp>
                          </elementProp>
                        </collectionProp>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${GeoserverHost}</stringProp>
                      <stringProp name="HTTPSampler.port">${GeoserverPort}</stringProp>
                      <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="HTTPSampler.protocol"></stringProp>
                      <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                      <stringProp name="HTTPSampler.path">/${GeoserverContextPath}/wms</stringProp>
                      <stringProp name="HTTPSampler.method">GET</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.implementation">Java</stringProp>
                      <boolProp name="HTTPSampler.monitor">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    </HTTPSamplerProxy>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
            </hashTree>
            <GenericController guiclass="LogicControllerGui" testclass="GenericController" testname="Zoomed in 1 step from initial model view" enabled="true"/>
            <hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Mapping Catch" enabled="true">
                <stringProp name="IfController.condition">${MapCatch}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
              </IfController>
              <hashTree>
                <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                  <stringProp name="groupSize">${MapRequestsConcurrentUsers}</stringProp>
                  <longProp name="timeoutInMs">0</longProp>
                </SyncTimer>
                <hashTree/>
                <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Reset thread to loop tiles" enabled="true">
                  <stringProp name="scriptLanguage">javascript</stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">vars.put(&quot;threadLoopIndex&quot;, -1);</stringProp>
                </BSFSampler>
                <hashTree/>
                <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Zoomed in 1 step from initial model view catch Transaction" enabled="true">
                  <boolProp name="TransactionController.includeTimers">false</boolProp>
                  <boolProp name="TransactionController.parent">false</boolProp>
                </TransactionController>
                <hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop all map tiles for map (catch zoom1 view)" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;mappedTilesPerUser&quot;)))}</stringProp>
                  </LoopController>
                  <hashTree>
                    <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init thread for a single tile request" enabled="true">
                      <stringProp name="scriptLanguage">javascript</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">var isDebug = props.get(&quot;EnableAppLevelDebugMessages&quot;);
var model = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextIndex = Number(props.get(&quot;contextIndex&quot;));
var contextId = props.get(&quot;contextId&quot;);
var totalTiles = Number(props.get(&quot;tilesTotal&quot;));
//var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var threadLoopIndex = vars.get(&quot;threadLoopIndex&quot;);	//How many times has this thread looped through the map loop?

//Starts at -1, so always increment before use
threadLoopIndex = Number(threadLoopIndex) + 1;


var tileIndex = ctx.getThreadNum() + (users * threadLoopIndex);	//Determine the tile to render based on the thread number &amp; how many times this thread has looped
var tile = model[&quot;zoom1ViewTiles&quot;][tileIndex];

if (isDebug == &quot;true&quot;) {
	log.info(&quot;Will map a zoomed in (1) catch tile for &quot; + modelId + 
	&quot; on thread &quot; + ctx.getThreadNum() + &quot; threadLoopIndex &quot; + threadLoopIndex + &quot; for tile index &quot; + tileIndex);
}


vars.put(&quot;modelId&quot;, modelId);
vars.put(&quot;contextId&quot;, contextId);
vars.put(&quot;north&quot;, Number(tile[&quot;north&quot;]));
vars.put(&quot;west&quot;, Number(tile[&quot;west&quot;]));
vars.put(&quot;south&quot;, Number(tile[&quot;south&quot;]));
vars.put(&quot;east&quot;, Number(tile[&quot;east&quot;]));
vars.put(&quot;flowLayerName&quot;, model[&quot;flowLayerNames&quot;][contextIndex]);
vars.put(&quot;catchLayerName&quot;, model[&quot;catchLayerNames&quot;][contextIndex]);
vars.put(&quot;localLayerName&quot;, model[&quot;localLayerNames&quot;][contextIndex]);


//debug &amp; index info
vars.put(&quot;thdnum&quot;, ctx.getThreadNum());
vars.put(&quot;threadLoopIndex&quot;, threadLoopIndex);
vars.put(&quot;tileIndex&quot;, tileIndex);
vars.put(&quot;contextIndex&quot;, contextIndex);
vars.put(&quot;rowcol&quot;, tile[&quot;rowcol&quot;]);</stringProp>
                    </BSFSampler>
                    <hashTree/>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Zoom1 Catch Tile" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments">
                          <elementProp name="thdNum" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${thdnum}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">thdNum</stringProp>
                          </elementProp>
                          <elementProp name="modelId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${modelId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">modelId</stringProp>
                          </elementProp>
                          <elementProp name="contextId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextId</stringProp>
                          </elementProp>
                          <elementProp name="contextIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextIdx</stringProp>
                          </elementProp>
                          <elementProp name="tileIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${tileIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">tileIdx</stringProp>
                          </elementProp>
                          <elementProp name="rowcol" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${rowcol}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">rowcol</stringProp>
                            <stringProp name="Argument.desc">false</stringProp>
                          </elementProp>
                          <elementProp name="threadLoopIndex" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${threadLoopIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">threadLoopIndex</stringProp>
                          </elementProp>
                          <elementProp name="request" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">GetMap</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">request</stringProp>
                          </elementProp>
                          <elementProp name="srs" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">EPSG:4326</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">srs</stringProp>
                          </elementProp>
                          <elementProp name="version" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">1.1.1</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">version</stringProp>
                          </elementProp>
                          <elementProp name="layers" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${catchLayerName}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">layers</stringProp>
                          </elementProp>
                          <elementProp name="BBOX" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${west},${south},${east},${north}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">BBOX</stringProp>
                          </elementProp>
                          <elementProp name="width" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">width</stringProp>
                          </elementProp>
                          <elementProp name="height" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">height</stringProp>
                          </elementProp>
                          <elementProp name="transparent" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">true</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">transparent</stringProp>
                          </elementProp>
                          <elementProp name="format" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">image/png8</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format</stringProp>
                          </elementProp>
                          <elementProp name="styles" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value"></stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">styles</stringProp>
                          </elementProp>
                          <elementProp name="format_options" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">antialiasing:none;quantizer:octree;</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format_options</stringProp>
                          </elementProp>
                          <elementProp name="sld" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">http://${GeoserverHost}:${GeoserverPort}/${GeoserverContextPath}/rest/sld/workspace/sparrow-catchment/layer/${localLayerName}/catch.sld?binLowList=0,25000,58000,141000,676000&amp;binHighList=25000,58000,141000,676000,500000000&amp;binColorList=FFFFD4,FEE391,FEC44F,FE9929,EC7014&amp;bounded=false</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">sld</stringProp>
                          </elementProp>
                        </collectionProp>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${GeoserverHost}</stringProp>
                      <stringProp name="HTTPSampler.port">${GeoserverPort}</stringProp>
                      <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="HTTPSampler.protocol"></stringProp>
                      <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                      <stringProp name="HTTPSampler.path">/${GeoserverContextPath}/wms</stringProp>
                      <stringProp name="HTTPSampler.method">GET</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.implementation">Java</stringProp>
                      <boolProp name="HTTPSampler.monitor">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    </HTTPSamplerProxy>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
              <IfController guiclass="IfControllerPanel" testclass="IfController" testname="If Mapping Reach" enabled="true">
                <stringProp name="IfController.condition">${MapReach}</stringProp>
                <boolProp name="IfController.evaluateAll">false</boolProp>
                <boolProp name="IfController.useExpression">true</boolProp>
              </IfController>
              <hashTree>
                <SyncTimer guiclass="TestBeanGUI" testclass="SyncTimer" testname="Synchronizing Timer" enabled="true">
                  <stringProp name="groupSize">${MapRequestsConcurrentUsers}</stringProp>
                  <longProp name="timeoutInMs">0</longProp>
                </SyncTimer>
                <hashTree/>
                <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Reset thread to loop tiles" enabled="true">
                  <stringProp name="scriptLanguage">javascript</stringProp>
                  <stringProp name="parameters"></stringProp>
                  <stringProp name="filename"></stringProp>
                  <stringProp name="script">vars.put(&quot;threadLoopIndex&quot;, -1);</stringProp>
                </BSFSampler>
                <hashTree/>
                <TransactionController guiclass="TransactionControllerGui" testclass="TransactionController" testname="Zoomed in 1 step from initial model view reach Transaction" enabled="true">
                  <boolProp name="TransactionController.includeTimers">false</boolProp>
                  <boolProp name="TransactionController.parent">false</boolProp>
                </TransactionController>
                <hashTree>
                  <LoopController guiclass="LoopControlPanel" testclass="LoopController" testname="Loop all map tiles for map (reach zoom1 view)" enabled="true">
                    <boolProp name="LoopController.continue_forever">true</boolProp>
                    <stringProp name="LoopController.loops">${__javaScript(Number(props.get(&quot;mappedTilesPerUser&quot;)))}</stringProp>
                  </LoopController>
                  <hashTree>
                    <BSFSampler guiclass="TestBeanGUI" testclass="BSFSampler" testname="Init thread for a single tile request" enabled="true">
                      <stringProp name="scriptLanguage">javascript</stringProp>
                      <stringProp name="parameters"></stringProp>
                      <stringProp name="filename"></stringProp>
                      <stringProp name="script">var isDebug = props.get(&quot;EnableAppLevelDebugMessages&quot;);
var model = props.get(&quot;currentModel&quot;);
var modelId = props.get(&quot;modelId&quot;);
var contextIndex = Number(props.get(&quot;contextIndex&quot;));
var contextId = props.get(&quot;contextId&quot;);
var totalTiles = Number(props.get(&quot;tilesTotal&quot;));
//var tilesPerUser = Number(props.get(&quot;tilesPerUser&quot;));
var users = Number(vars.get(&quot;MapRequestsConcurrentUsers&quot;));
var threadLoopIndex = vars.get(&quot;threadLoopIndex&quot;);	//How many times has this thread looped through the map loop?

//Starts at -1, so always increment before use
threadLoopIndex = Number(threadLoopIndex) + 1;


var tileIndex = ctx.getThreadNum() + (users * threadLoopIndex);	//Determine the tile to render based on the thread number &amp; how many times this thread has looped
var tile = model[&quot;zoom1ViewTiles&quot;][tileIndex];

if (isDebug == &quot;true&quot;) {
	log.info(&quot;Will map a zoomed in (1) reach tile for &quot; + modelId + 
	&quot; on thread &quot; + ctx.getThreadNum() + &quot; threadLoopIndex &quot; + threadLoopIndex + &quot; for tile index &quot; + tileIndex);
}


vars.put(&quot;modelId&quot;, modelId);
vars.put(&quot;contextId&quot;, contextId);
vars.put(&quot;north&quot;, Number(tile[&quot;north&quot;]));
vars.put(&quot;west&quot;, Number(tile[&quot;west&quot;]));
vars.put(&quot;south&quot;, Number(tile[&quot;south&quot;]));
vars.put(&quot;east&quot;, Number(tile[&quot;east&quot;]));
vars.put(&quot;flowLayerName&quot;, model[&quot;flowLayerNames&quot;][contextIndex]);
vars.put(&quot;catchLayerName&quot;, model[&quot;catchLayerNames&quot;][contextIndex]);
vars.put(&quot;localLayerName&quot;, model[&quot;localLayerNames&quot;][contextIndex]);


//debug &amp; index info
vars.put(&quot;thdnum&quot;, ctx.getThreadNum());
vars.put(&quot;threadLoopIndex&quot;, threadLoopIndex);
vars.put(&quot;tileIndex&quot;, tileIndex);
vars.put(&quot;contextIndex&quot;, contextIndex);
vars.put(&quot;rowcol&quot;, tile[&quot;rowcol&quot;]);</stringProp>
                    </BSFSampler>
                    <hashTree/>
                    <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Zoom1 Reach Tile" enabled="true">
                      <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
                        <collectionProp name="Arguments.arguments">
                          <elementProp name="thdNum" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${thdnum}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">thdNum</stringProp>
                          </elementProp>
                          <elementProp name="modelId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${modelId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">modelId</stringProp>
                          </elementProp>
                          <elementProp name="contextId" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextId}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextId</stringProp>
                          </elementProp>
                          <elementProp name="contextIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${contextIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">contextIdx</stringProp>
                          </elementProp>
                          <elementProp name="tileIdx" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${tileIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">tileIdx</stringProp>
                          </elementProp>
                          <elementProp name="rowcol" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${rowcol}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">rowcol</stringProp>
                            <stringProp name="Argument.desc">false</stringProp>
                          </elementProp>
                          <elementProp name="threadLoopIndex" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">false</boolProp>
                            <stringProp name="Argument.value">${threadLoopIndex}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">threadLoopIndex</stringProp>
                          </elementProp>
                          <elementProp name="request" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">GetMap</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">request</stringProp>
                          </elementProp>
                          <elementProp name="srs" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">EPSG:4326</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">srs</stringProp>
                          </elementProp>
                          <elementProp name="version" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">1.1.1</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">version</stringProp>
                          </elementProp>
                          <elementProp name="layers" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${flowLayerName}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">layers</stringProp>
                          </elementProp>
                          <elementProp name="BBOX" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">${west},${south},${east},${north}</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">BBOX</stringProp>
                          </elementProp>
                          <elementProp name="width" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">width</stringProp>
                          </elementProp>
                          <elementProp name="height" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">256</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">height</stringProp>
                          </elementProp>
                          <elementProp name="transparent" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">true</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">transparent</stringProp>
                          </elementProp>
                          <elementProp name="format" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">image/png8</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format</stringProp>
                          </elementProp>
                          <elementProp name="styles" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value"></stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">styles</stringProp>
                          </elementProp>
                          <elementProp name="format_options" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">antialiasing:none;quantizer:octree;</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">format_options</stringProp>
                          </elementProp>
                          <elementProp name="sld" elementType="HTTPArgument">
                            <boolProp name="HTTPArgument.always_encode">true</boolProp>
                            <stringProp name="Argument.value">http://${GeoserverHost}:${GeoserverPort}/${GeoserverContextPath}/rest/sld/workspace/sparrow-flowline/layer/${localLayerName}/catch.sld?binLowList=0,25000,58000,141000,676000&amp;binHighList=25000,58000,141000,676000,500000000&amp;binColorList=FFFFD4,FEE391,FEC44F,FE9929,EC7014&amp;bounded=false</stringProp>
                            <stringProp name="Argument.metadata">=</stringProp>
                            <boolProp name="HTTPArgument.use_equals">true</boolProp>
                            <stringProp name="Argument.name">sld</stringProp>
                          </elementProp>
                        </collectionProp>
                      </elementProp>
                      <stringProp name="HTTPSampler.domain">${GeoserverHost}</stringProp>
                      <stringProp name="HTTPSampler.port">${GeoserverPort}</stringProp>
                      <stringProp name="HTTPSampler.connect_timeout"></stringProp>
                      <stringProp name="HTTPSampler.response_timeout"></stringProp>
                      <stringProp name="HTTPSampler.protocol"></stringProp>
                      <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
                      <stringProp name="HTTPSampler.path">/${GeoserverContextPath}/wms</stringProp>
                      <stringProp name="HTTPSampler.method">GET</stringProp>
                      <boolProp name="HTTPSampler.follow_redirects">false</boolProp>
                      <boolProp name="HTTPSampler.auto_redirects">true</boolProp>
                      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
                      <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
                      <stringProp name="HTTPSampler.implementation">Java</stringProp>
                      <boolProp name="HTTPSampler.monitor">false</boolProp>
                      <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
                    </HTTPSamplerProxy>
                    <hashTree/>
                  </hashTree>
                </hashTree>
              </hashTree>
            </hashTree>
          </hashTree>
        </hashTree>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
